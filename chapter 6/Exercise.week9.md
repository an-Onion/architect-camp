# 极客时间《架构师训练营》第九周课后作业

## 作业一

> 请简述 JVM 垃圾回收原理

垃圾回收就是清除 JVM 堆内不再被引用的对象。

### 可达性分析

从`GC Roots`对象出发一路向下遍历，将遍历到的对象标记为可达，其他对象即不可达。其中`GC Root`包括：栈中引用对象、方法区中的静态或是常量引用，以及本地方法栈中的 JNI 引用对象。

![可达性][2]

### GC 算法

经可达性分析后，那些不可达的对象将等待回收。常用的回收算法有：

1. mark-sweep 标记清除法：将标记的回收区域直接清空

2. mark-copy 标记拷贝法：将内存对半分，总保留一半是空闲的；回收时，将零散存活的对象连续地复制到另一半的空闲内存区。

3. mark-compact 标记合并法：先清理垃圾对象，再挪动存活对象，并保证连续存储

4. generation-collect 分代收集算法

    内存被分为三大块：新生代、老年代、永久代；新生代又细分为 Eden 区和两个 Survivor 区：

    ![分代收集算法][0]

    分代收集算法提供了两种模式：

    * Minor GC 也叫 Young GC，顾名思义主要在新生代活动的回收机制：

      1. Eden 满了，标记复制到 S0；Eden 清空
      2. Eden+S0 满了，标记复制到 S1；Eden 和 S0 清空
      3. Eden+S1 满了，标记复制 S0；Eden 和 S1 清空
      4. 循环往复步骤 2、3
      5. 将 S0 和 S1 间多次往复的标记块晋升到老年代

    * Major GC：老年代也满了，就整体标记清除或是标记合并一下，但是会比较耗时

### 垃圾回收器

垃圾回收器一直在发展，一共经历了四个阶段：

1. Serial（串行）收集器
2. Parallel（并行）收集器
3. CMS（并发）收集器
4. G1 收集器

主要说说 G1 收集器。G1 之前的 JVM 堆模型如上面分代收集算法提到的，分为新生代、老年代和永久代。G1 改变了这个模型，堆被分为多个大小连续的区域，这些区域被标记为 E、S、O 和 H，分别对应 Eden，Survivor，Old 区和巨型区。

![G1收集器][1]

G1 也有两种收集模式：

* Young GC： 当 Eden 区达到一定阈值时触发；会将 Eden 和 Survivor 清理，并复制到 Old 区以及一部分 Survivor 区。

* MixedGC：Old 区也达到一定阈值时，回收所有 Eden 区、Survivor 区，以及部分 Old 区的内存。

## 作业二

> 设计一个秒杀系统，主要的挑战和问题有哪些？核心的架构方案或者思路有哪些？

[0]: ./img/generation.png
[1]: ./img/G1.png
[2]: ./img/reachable.png
