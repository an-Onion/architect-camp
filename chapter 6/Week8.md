# 极客时间《架构师训练营》第八周学习笔记

身体不大舒服，先列个提纲，把作业交了；明后天再补充内容。

## 数据结构与算法

### 空间复杂度和时间复杂度

### 数据结构

* 数组
* 链表
* Hash 表
* 栈
* 队列
* 树
* 调表

* 二叉查找树（BST）：运用了二分查找的思想，查找所需的最大次数等于树的高度

  1. 左子树上所有结点的值均小于或等于它的根结点的值。
  2. 右子树上所有结点的值均大于或等于它的根结点的值。
  3. 左、右子树也分别为二叉排序树。

缺点是可能会成为单边的二叉树，搜索时间复杂度为 O(n)，所以需要二叉查找树（AVL）或是红黑树

* 红黑树： 自平衡的二叉查找树，能保证根到叶子的最长路劲不会超过最短路径的 2 倍

  1. 结点是红色或黑色。
  2. 根结点是黑色。
  3. 每个叶子结点都是黑色的空结点（NIL 结点）。
  4. 每个红色结点的两个子结点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色结点)
  5. 从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。

### 算法

* 递归
* 贪心
* 动态规划
* 遗传算法

## 网络通信

### OSI 七层模型 v.s. TCP/IP 四层模型

网络传输控制协议有两种最基本的模型——OSI 和 TCP/IP 协议。两者的区别如下所示：两种都是标准模型，相比之下 OSI 更为严谨详实；但是经过多年斗争，TCP/IP 最终胜出，因为简单粗暴才更能被广泛应用。

![OSI v.s. TCP/IP][2]

下面是 TPC/IP 各层协议，我们常听见的专业术语其实都是 TCP/IP 里某一层的协议：

| 模型        | 协议 |
| ---------- | --- |
| 应用层      | HTTP, DNS, SSH, RPC, Telnet, FTP,  SMTP |
| 传输层      | TCP, UDP |
| 网络层      | IP, ICMP, ARP |
| 数据链路层  | Ethernet, Fast Eth, Token Ring, FDDI |

### HTTP 协议

应用层中最最常用就是 HTTP 协议；它是一种在客户端和服务器之间编码和传输数据的方法，一个请求/响应协议：客户端和服务端针对相关内容和完成状态信息的请求和响应。HTTP 是独立的，允许请求和响应流经许多执行负载均衡，缓存，加密和压缩的中间路由器和服务器。

一个基本的 HTTP 请求由一个动词（方法）和一个资源（端点）组成。 以下是常见的 HTTP 动词：

| 动词   | 描述            | 幂等 | 安全性  | 可缓存            |
| ------ | -------------- | ---- | ---- | -------------- |
| GET    | 读取资源                   | Yes  | Yes  | Yes            |
| POST   | 创建资源或触发处理数据的进程 | No   | No   | Yes，如果回应包含刷新信息 |
| PUT    | 创建或替换资源              | Yes  | No   | No             |
| PATCH  | 部分更新资源                | No   | No   | Yes，如果回应包含刷新信息 |
| DELETE | 删除资源                   | Yes  | No   | No             |

此外还有两个动词`Trace`和`Options`用于测试或诊断，小众需求。

HTTP（HyperText Transfer Protocol）从 1989 年万维网诞生之日起就经历了众多版本迭代，早期经典版本有 1991 年出的 HTTP0.9 和 1996 年的 HTTP1.0，但是现在很少用到了。我自己最经常用的事实上是 HTTP1.1——用 Postman 调试 RESTFUL API 时用到的协议。

* HTTP1.1 相比于 1.0 版本 b 默认启用长连接，客户端可以不用等上一个请求响应结果就可以发送下一个请求了。但是天生缺陷：队头阻塞、无状态、明文传输、不支持推送等等。

* HTTPS 在 HTTP 协议下多加了一层加密协议——ssl／tls 协议。现在主流的 Web 前后端通讯基本都用 HTTPS 了。

* HTTP2 是基于 google 的 SPDY 协议推行的改进版——多路复用、头部压缩、支持服务端推送、加密传输。

* HTTP3 相比于之前的版本就是另起炉灶的另一种协议了。它基于的底层协议不是 TCP 而是 UDP，改进了之前的拥塞控制，提升了多路复用和连接迁移；但是落地可能仍需一定时日。

![HTTP][5]

### TCP

上面的 HTTP 是依赖于传输层协议 TCP 和 UDP 的应用层协议。我们再来看一下更低层的 TCP 协议。TCP 是通过 IP 网络的面向连接的协议。使用握手建立和断开连接。

* TCP 建立连接就是经典的**三次握手**，过程如下：

  1. 客户端向服务器发起一个 SYN 包
  2. 服务器端返回对应的 SYN 的 ACK 响应以及新的 SYN 包
  3. 然后客户端返回对应的 ACK

  ![三次握手][3]

* 断开连接是**四次挥手**：

  1. 客户端发送一个 FIN 段，并包含一个希望接收者看到的自己当前的序列号 K. 同时还包含一个 ACK 表示确认对方最近一次发过来的数据
  2. 服务端将 K 值加 1 作为 ACK 序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作
  3. 服务端发起自己的 FIN 段，ACK=K+1, Seq=L
  4. 客户端确认，ACK=L+1

  ![四次挥手][4]

### IP

IP 是 Internet Protocol（网际互连协议）的缩写，是 TCP/IP 体系中的网络层协议，可将 IP 信息包从源设备传送到目的设备。IP 协议依赖于 IP 地址（网络中唯一的地址）和路由（传送方式）两种机制。我们最常用的负载均衡——IP 负载均衡，就是通过 IP 地址分发流量到不同的服务器中。

## 非阻塞网络 I/O

### Socket

回顾了 TCP/IP 模型，那计算机之间如何进行网络请求呢？用的是软件手段——Socket。

Socket 是应用层与传输层（TCP、UDP）之间的一个软件抽象层，它是一组接口。在设计模式中，Socket 其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面，对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。

![Socket][6]

Socket 通信的过程如下：

1. 服务器端先初始化 Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用 accept 阻塞，等待客户端连接
2. 客户端初始化一个 Socket，然后连接服务器(connect)；如果成功，客户端与服务器端的连接就建立了
3. 客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据
4. 最后关闭连接，一次交互结束

### Java IO

Socket 是操作系统提供给用户的网络编程接口，但是对开发来说还是过于底层。一般我们调用的是它的进一步封装，如 Java IO。

![Java Blocking IO][7]

Java IO 是 JDK `java.net` 下面的一组 API，调用方法如下：

1. ServerSocket 创建并监听某端口
2. 客户端请求连接，Socket 就返回 `accept()`， 然后它自己就 block 住了
3. 之后客户端和服务器就可以互发数据了

由于 Socket 接受连接后就被 block 住了，假如你想支持并发，只能建线程池。不过线程数量有限，你无法突破这个上限。

### Java NIO

然后就有了改进版的 Java NIO：

![Java NIO][8]

Java NIO 知识点很多——Channel、BUffer、Selector、Selection Key。篇幅有限就不一一列举了，只说重点。Java NIO 可以提高并发量（或是不阻塞），关键点在 Selector 上：虽然和上述的`accept()`阻塞一样，调`select()`时也会阻塞；但是它可以注册多个 channel，使得单个线程可以 handle 多个连接，这样就可以应对更高的并发量了。

![Selector Model][9]

## 数据库原理与性能优化

### 数据库架构

* 连接器：为每个请求分配一块专用的内存空间用于会话上下文。应用启动时通常会创建一个连接池用于加速数据库连接。

* 语法分析器：检测 SQL 语法是否正确

* 语义分析与优化：将常见的复杂嵌套语句转化成更高效的索引语句，但是种类比较有限吧

* 执行引擎：生成执行计划，可以用`explain`查看执行计划包含的信息，一般有 Id、type、key，rows 等等信息。

![数据库架构][10]

### 索引

在几百万行的数据库里查找记录，需要全表扫描，效率很低。我们可以选择建索引提速。所以事实上就是创建一个 B+树，在`O(log n)`时间内找到节点。

### 事务

* 原子性（Atomicity）：每个事务内部所有操作要么全部完成，要么全部不完成
* 一致性（Consistency ）：任何事务都使数据库从一个有效的状态转换到另一个有效状态
* 隔离性（Isolation）：并发执行事务的结果与顺序执行事务的结果相同
* 持久性（Durability ）：事务提交后，对系统的影响是永久的

### 日志

|MySql 日志类型 | 解析说明|
|---|---|
|错误日志（error log）| 当数据库启动、运行、停止时产生该日志|
|普通查询日志（general query log）| 客户端连接数据库执行语句时产生该日志|
|二进制日志（binary log）| 当数据库内容发生改变时产生该日志，也被用来实现主从复制功能|
|中继日志（relay log）| 从库上收到主库的数据更新时产生该日志|
|慢查询日志（show query log）| SQL 语句在数据库查询超过指定时间时产生该日志|
|DDL 日志（metadata log）| 执行 DDL 语句操作元数据时产生该日志|

[2]: ./img/OSI.png
[3]: ./img/three-some.png
[4]: ./img/four-some.png
[5]: ./img/http.jpg
[6]: ./img/socket.jpg
[7]: ./img/blocking_java_io.png
[8]: ./img/nio_java.png
[9]: ./img/selector.png
[10]: ./img/DB.png
